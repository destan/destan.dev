<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Understanding how idempotent endpoints can return different HTTP responses while maintaining server state consistency, with examples and RFC 9110 references.">
    <meta name="keywords" content="idempotent, HTTP responses, REST API, RFC 9110, server state, API design">
    <meta name="author" content="Destan Sarpkaya">

    <!-- SEO-friendly fallback content for web components -->
    <noscript>
        <style>
            code[class*=language-], pre[class*=language-] {
                text-shadow: none !important;
            }
        </style>
    </noscript>

    <!-- Preload Ubuntu font files directly -->
    <link rel="preload" href="https://fonts.gstatic.com/s/ubuntu/v20/4iCs6KVjbNBYlgoKfw72.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Ubuntu&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu&display=swap"></noscript>

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://destan.dev/blog/tech/idempotent-response-codes">
    <meta property="og:title" content="Idempotent Endpoints: Different Responses, Same Server State">
    <meta property="og:description" content="Learn how idempotent endpoints can return different HTTP responses while maintaining server state consistency.">
    <meta property="og:image" content="https://destan.dev/images/idempotent-response-codes.jpg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://destan.dev/blog/tech/idempotent-response-codes">
    <meta property="twitter:title" content="Idempotent Endpoints: Different Responses, Same Server State">
    <meta property="twitter:description" content="Learn how idempotent endpoints can return different HTTP responses while maintaining server state consistency.">
    <meta property="twitter:image" content="https://destan.dev/images/idempotent-response-codes.jpg">

    <title>Idempotent Endpoints: Different Responses, Same Server State | DevBlog</title>

    <!-- Preload and load shared CSS -->
    <link rel="preload" href="../shared.css" as="style">
    <link href="../shared.css" rel="stylesheet">

    <!-- Load Prism.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/themes/prism-twilight.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/plugins/autoloader/prism-autoloader.min.js"></script>

</head>
<body>
<site-header>
    <bread-crumbs>Home > Blog > Tech</bread-crumbs>
    <current-page>Idempotent Responses</current-page>
</site-header>

<main class="main-content">
    <div class="container">
        <article>
            <article-header>
                <h1 slot="title">Idempotent Endpoints: Different Responses, Same Server State</h1>
                <p slot="subtitle">Understanding How HTTP Responses Can Vary While Maintaining Idempotency</p>
                <time datetime="2025-07-26" slot="date">2025-07-26</time>
            </article-header>

            <section class="content-section">
                <p>A common misconception about idempotent endpoints is that they must return identical responses for consecutive calls. However, according to <a href="https://www.rfc-editor.org/rfc/rfc9110#name-idempotent-methods" target="_blank" rel="noopener">RFC 9110 Section 9.2.2</a>, idempotency is about maintaining the same <strong>server state</strong>, not necessarily the same response codes or content.</p>

                <callout-box type="info">
                    <p>ðŸŽ¯ Key Insight</p>
                    <p>Idempotency guarantees that multiple identical requests have the same <em>effect</em> on server state, but the HTTP response can legitimately differ between calls.</p>
                </callout-box>
            </section>

            <section class="content-section">
                <h2 id="rfc-definition">RFC 9110: The Authoritative Definition</h2>

                <p>The <a href="https://www.rfc-editor.org/rfc/rfc9110#name-idempotent-methods" target="_blank" rel="noopener">HTTP Semantics specification (RFC 9110)</a> defines idempotent methods as those where "multiple identical requests have the same effect as a single request." This definition focuses on the <em>effect</em> rather than the response.</p>

                <blockquote>
                    "A request method is considered 'idempotent' if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request." 
                    <cite>â€” <a href="https://www.rfc-editor.org/rfc/rfc9110#name-idempotent-methods" target="_blank" rel="noopener">RFC 9110, Section 9.2.2</a></cite>
                </blockquote>

                <p>Notice how the specification emphasizes "intended effect on the server" rather than response consistency.</p>
            </section>

            <section class="content-section">
                <h2 id="practical-examples">Examples</h2>

                <h3 id="put-example">PUT: Create vs Update</h3>

                <p>The most common example is a PUT request that creates a resource on the first call and updates it on subsequent calls:</p>

                <pre><code class="language-http">PUT /api/users/123 HTTP/1.1
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}</code></pre>

                <pre><code class="language-javascript">// First call - resource doesn't exist
// Response: 201 Created
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2025-07-26T10:00:00Z",
  "updated_at": "2025-07-26T10:00:00Z"
}

// Second call - resource exists with same data
// Response: 200 OK
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2025-07-26T10:00:00Z",
  "updated_at": "2025-07-26T10:00:00Z"  // No change
}</code></pre>

                <p>The server state is identical after both calls (user 123 exists with the specified data), but the response codes differ to accurately reflect what happened.</p>

                <h3 id="delete-example">DELETE: Success vs Already Gone</h3>

                <pre><code class="language-http">DELETE /api/users/123 HTTP/1.1</code></pre>

                <pre><code class="language-javascript">// First call - user exists and is deleted
// Response: 200 OK or 204 No Content
{
  "message": "User deleted successfully"
}

// Second call - user already deleted
// Response: 404 Not Found or 410 Gone
{
  "error": "User not found",
  "code": "USER_NOT_FOUND"
}</code></pre>

                <p>Both calls achieve the same server state (user 123 doesn't exist), but the responses rightfully differ.</p>

                <h3 id="post-with-idempotency">POST with Idempotency Keys</h3>

                <pre><code class="language-http">POST /api/payments HTTP/1.1
Content-Type: application/json
Idempotency-Key: payment-abc-123

{
  "amount": 100.00,
  "recipient": "user-456"
}</code></pre>

                <pre><code class="language-javascript">// First call - payment processed
// Response: 201 Created
{
  "id": "pay_xyz789",
  "amount": 100.00,
  "status": "completed",
  "created_at": "2025-07-26T10:00:00Z"
}

// Duplicate call with same idempotency key
// Response: 409 Conflict (or 200 OK with existing resource)
{
  "id": "pay_xyz789",
  "amount": 100.00,
  "status": "completed",
  "created_at": "2025-07-26T10:00:00Z",
  "error": "Payment already processed with this idempotency key"
}</code></pre>

                <p>The payment state is identical (exactly one payment processed), but the response code indicates a duplicate request was detected.</p>
            </section>
        </article>

        <labels-component>idempotency, HTTP, REST, RFC 9110</labels-component>

        <author-bio 
            author="Destan Sarpkaya"
            author-initials="DS"
            title="Software Architect">
        </author-bio>
    </div>
</main>

<site-footer></site-footer>

<back-to-top></back-to-top>

<!-- Load Individual Components -->
<script src="../components/site-header.js"></script>
<script src="../components/article-header.js"></script>
<script src="../components/site-footer.js"></script>
<script src="../components/back-to-top.js"></script>
<script src="../components/callout-box.js"></script>
<script src="../components/labels.js"></script>
<script src="../components/author-bio.js"></script>
<script src="../components/smooth-scroll.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize smooth scrolling
        if (!document.querySelector('smooth-scroll')) {
            const smoothScroll = document.createElement('smooth-scroll');
            smoothScroll.style.display = 'none';
            document.body.appendChild(smoothScroll);
        }

        // Add overflow detection for code blocks on mobile
        function handleCodeBlockOverflow() {
            const codeBlocks = document.querySelectorAll('pre[class*="language-"]');
            codeBlocks.forEach(block => {
                if (block.scrollWidth > block.clientWidth) {
                    block.setAttribute('data-overflowing', 'true');
                } else {
                    block.removeAttribute('data-overflowing');
                }
            });
        }

        handleCodeBlockOverflow();
        window.addEventListener('resize', handleCodeBlockOverflow);
    });
</script>
</body>
</html>